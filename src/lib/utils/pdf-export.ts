/**
 * PDF Export Utility
 *
 * Generates formatted PDF reports for dashboard analytics
 * Supports multi-page reports with tables, metrics, and text sections
 *
 * Part of Epic 6: Lead Tracking Dashboard Enhancement - Story 6.5
 */

import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';
import { logger } from '@/lib/logger';

// Extended jsPDF type with autoTable plugin properties
interface JsPDFWithAutoTable extends jsPDF {
  lastAutoTable?: {
    finalY: number;
  };
  internal: {
    getNumberOfPages(): number;
    pageSize: {
      width: number;
      height: number;
      getWidth(): number;
      getHeight(): number;
    };
  };
}

interface TableData {
  headers: string[];
  rows: (string | number)[][];
}

interface MetricsData {
  metrics: Array<{ label: string; value: string | number }>;
}

interface TextData {
  text: string;
}

type ReportSectionData = TableData | MetricsData | TextData;

export interface ReportSection {
  title: string;
  type: 'table' | 'text' | 'metrics';
  data: ReportSectionData;
}

export interface MaterialPerformance {
  id: string;
  title: string;
  type: string;
  clicks: number;
  intakeStarts: number;
  intakeCompletes: number;
  returnsFiled: number;
  conversionRate: number;
}

export interface DashboardData {
  totalClicks: number;
  conversions: number;
  conversionRate: number;
  materials: MaterialPerformance[];
  userName: string;
}

export interface FunnelData {
  stage1_clicks: number;
  stage2_intakeStarts: number;
  stage3_intakeCompletes: number;
  stage4_returnsFiled: number;
  conversionRates: {
    clickToStart: number;
    startToComplete: number;
    completeToFiled: number;
    overallConversion: number;
  };
  dropoff: {
    clickToStart: number;
    startToComplete: number;
    completeToFiled: number;
  };
}

/**
 * Generate PDF report from sections
 * Enhanced with comprehensive error handling (QA Gate Issue MNT-001)
 */
export async function generatePDFReport(params: {
  title: string;
  sections: ReportSection[];
  dateRange: string;
  generatedBy: string;
}): Promise<Blob> {
  try {
    const doc = new jsPDF() as JsPDFWithAutoTable;
    let yPosition = 20;

    // Header - with error handling
    try {
      doc.setFontSize(20);
      doc.text(params.title || 'Report', 20, yPosition);
      yPosition += 10;

      doc.setFontSize(10);
      doc.setTextColor(100);
      doc.text(`Generated: ${new Date().toLocaleString()}`, 20, yPosition);
      yPosition += 5;
      doc.text(`Date Range: ${params.dateRange || 'N/A'}`, 20, yPosition);
      yPosition += 5;
      doc.text(`Generated By: ${params.generatedBy || 'System'}`, 20, yPosition);
      yPosition += 15;

      // Reset text color
      doc.setTextColor(0);
    } catch (headerError) {
      logger.error('PDF Header Generation Error:', headerError);
      // Continue with default positioning
      yPosition = 60;
    }

    // Render sections with individual error handling
    for (const section of params.sections) {
      try {
        // Check if we need a new page
        if (yPosition > 250) {
          doc.addPage();
          yPosition = 20;
        }

        doc.setFontSize(14);
        doc.text(section.title || 'Section', 20, yPosition);
        yPosition += 10;

        // Handle table sections
        if (section.type === 'table') {
          try {
            if (!section.data?.headers || !section.data?.rows) {
              throw new Error('Invalid table data: missing headers or rows');
            }

            autoTable(doc, {
              startY: yPosition,
              head: [section.data.headers],
              body: section.data.rows,
              theme: 'grid',
              styles: { fontSize: 8, cellPadding: 3 },
              headStyles: { fillColor: [41, 128, 185], textColor: 255 },
              margin: { left: 20, right: 20 },
            });
            yPosition = (doc.lastAutoTable?.finalY ?? yPosition) + 10;
          } catch (tableError) {
            logger.error(`PDF Table Generation Error (${section.title}):`, tableError);
            doc.setFontSize(10);
            doc.setTextColor(200, 0, 0);
            doc.text('Error rendering table data', 30, yPosition);
            doc.setTextColor(0);
            yPosition += 10;
          }
        }

        // Handle metrics sections
        if (section.type === 'metrics') {
          try {
            const metricsData = section.data as MetricsData;
            if (!metricsData?.metrics || !Array.isArray(metricsData.metrics)) {
              throw new Error('Invalid metrics data: expected array');
            }

            doc.setFontSize(10);
            metricsData.metrics.forEach((metric) => {
              if (metric && metric.label && metric.value !== undefined) {
                doc.text(`${metric.label}: ${metric.value}`, 30, yPosition);
                yPosition += 6;
              }
            });
            yPosition += 10;
          } catch (metricsError) {
            logger.error(`PDF Metrics Generation Error (${section.title}):`, metricsError);
            doc.setFontSize(10);
            doc.setTextColor(200, 0, 0);
            doc.text('Error rendering metrics data', 30, yPosition);
            doc.setTextColor(0);
            yPosition += 10;
          }
        }

        // Handle text sections
        if (section.type === 'text') {
          try {
            if (!section.data?.text) {
              throw new Error('Invalid text data: missing text property');
            }

            doc.setFontSize(10);
            const lines = doc.splitTextToSize(section.data.text, 170);
            doc.text(lines, 20, yPosition);
            yPosition += lines.length * 6 + 10;
          } catch (textError) {
            logger.error(`PDF Text Generation Error (${section.title}):`, textError);
            doc.setFontSize(10);
            doc.setTextColor(200, 0, 0);
            doc.text('Error rendering text content', 30, yPosition);
            doc.setTextColor(0);
            yPosition += 10;
          }
        }
      } catch (sectionError) {
        logger.error(`PDF Section Error (${section.title || 'Unknown'}):`, sectionError);
        // Continue to next section
      }
    }

    // Footer on last page - with error handling
    try {
      const pageCount = doc.internal.getNumberOfPages();
      doc.setFontSize(8);
      doc.setTextColor(150);
      doc.text(`Tax Genius Pro - Page ${pageCount}`, 20, doc.internal.pageSize.height - 10);
    } catch (footerError) {
      logger.error('PDF Footer Generation Error:', footerError);
      // Footer is optional, continue
    }

    // Generate and return blob
    try {
      return doc.output('blob');
    } catch (outputError) {
      logger.error('PDF Output Generation Error:', outputError);
      throw new Error('Failed to generate PDF file. Please try again.');
    }
  } catch (error) {
    logger.error('PDF Generation Critical Error:', error);
    throw new Error(
      error instanceof Error
        ? `PDF Generation Failed: ${error.message}`
        : 'An unexpected error occurred while generating the PDF report'
    );
  }
}

/**
 * Export dashboard overview report to PDF
 * Enhanced with error handling (QA Gate Issue MNT-001)
 */
export async function exportDashboardReport(dashboardData: DashboardData): Promise<void> {
  try {
    const sections: ReportSection[] = [
      {
        title: 'Performance Overview',
        type: 'metrics',
        data: {
          metrics: [
            { label: 'Total Clicks', value: dashboardData.totalClicks.toLocaleString() },
            { label: 'Total Conversions', value: dashboardData.conversions.toLocaleString() },
            { label: 'Conversion Rate', value: `${dashboardData.conversionRate.toFixed(2)}%` },
            { label: 'Total Materials', value: dashboardData.materials.length.toLocaleString() },
          ],
        },
      },
    ];

    // Add Top 15 Materials table (or fewer if less than 15)
    const topMaterials = dashboardData.materials.slice(0, 15);
    if (topMaterials.length > 0) {
      sections.push({
        title: `Top ${topMaterials.length} Performing Materials`,
        type: 'table',
        data: {
          headers: ['Rank', 'Material', 'Type', 'Clicks', 'Conversions', 'Rate'],
          rows: topMaterials.map((m, idx) => [
            idx + 1,
            m.title.substring(0, 30), // Truncate long titles
            formatType(m.type),
            m.clicks.toLocaleString(),
            m.returnsFiled.toLocaleString(),
            `${m.conversionRate.toFixed(1)}%`,
          ]),
        },
      });
    }

    const blob = await generatePDFReport({
      title: 'Tax Genius Pro - Performance Report',
      sections,
      dateRange: 'Last 30 days',
      generatedBy: dashboardData.userName,
    });

    // Download
    downloadBlob(blob, `dashboard-report-${new Date().toISOString().split('T')[0]}.pdf`);
  } catch (error) {
    logger.error('Dashboard Report Export Error:', error);
    throw new Error(
      error instanceof Error
        ? `Failed to export dashboard report: ${error.message}`
        : 'Failed to export dashboard report. Please try again.'
    );
  }
}

/**
 * Export materials performance report to PDF
 */
export async function exportMaterialsReport(params: {
  materials: MaterialPerformance[];
  userName: string;
  dateRange: string;
}): Promise<void> {
  const { materials, userName, dateRange } = params;

  // Calculate summary metrics
  const totalClicks = materials.reduce((sum, m) => sum + m.clicks, 0);
  const totalConversions = materials.reduce((sum, m) => sum + m.returnsFiled, 0);
  const avgConversionRate =
    materials.length > 0
      ? materials.reduce((sum, m) => sum + m.conversionRate, 0) / materials.length
      : 0;

  const sections: ReportSection[] = [
    {
      title: 'Materials Summary',
      type: 'metrics',
      data: {
        metrics: [
          { label: 'Total Materials', value: materials.length.toLocaleString() },
          { label: 'Total Clicks', value: totalClicks.toLocaleString() },
          { label: 'Total Conversions', value: totalConversions.toLocaleString() },
          { label: 'Average Conversion Rate', value: `${avgConversionRate.toFixed(2)}%` },
        ],
      },
    },
    {
      title: 'Materials Performance Detail',
      type: 'table',
      data: {
        headers: ['Material', 'Type', 'Clicks', 'Started', 'Completed', 'Filed', 'Rate'],
        rows: materials.map((m) => [
          m.title.substring(0, 25),
          formatType(m.type),
          m.clicks.toLocaleString(),
          m.intakeStarts.toLocaleString(),
          m.intakeCompletes.toLocaleString(),
          m.returnsFiled.toLocaleString(),
          `${m.conversionRate.toFixed(1)}%`,
        ]),
      },
    },
  ];

  const blob = await generatePDFReport({
    title: 'Materials Performance Report',
    sections,
    dateRange,
    generatedBy: userName,
  });

  downloadBlob(blob, `materials-report-${new Date().toISOString().split('T')[0]}.pdf`);
}

/**
 * Export funnel analysis report to PDF
 */
export async function exportFunnelReport(params: {
  funnelData: FunnelData;
  userName: string;
  dateRange: string;
  materialName?: string;
}): Promise<void> {
  const { funnelData, userName, dateRange, materialName } = params;

  const sections: ReportSection[] = [
    {
      title: materialName ? `Funnel Analysis - ${materialName}` : 'Funnel Analysis - All Materials',
      type: 'metrics',
      data: {
        metrics: [
          { label: 'Stage 1: Link Clicked', value: funnelData.stage1_clicks.toLocaleString() },
          {
            label: 'Stage 2: Intake Started',
            value: funnelData.stage2_intakeStarts.toLocaleString(),
          },
          {
            label: 'Stage 3: Intake Completed',
            value: funnelData.stage3_intakeCompletes.toLocaleString(),
          },
          {
            label: 'Stage 4: Return Filed',
            value: funnelData.stage4_returnsFiled.toLocaleString(),
          },
        ],
      },
    },
    {
      title: 'Conversion Rates',
      type: 'table',
      data: {
        headers: ['Stage Transition', 'Conversion Rate', 'Drop-off Rate'],
        rows: [
          [
            'Click → Intake Start',
            `${funnelData.conversionRates.clickToStart.toFixed(1)}%`,
            `${funnelData.dropoff.clickToStart.toFixed(1)}%`,
          ],
          [
            'Intake Start → Complete',
            `${funnelData.conversionRates.startToComplete.toFixed(1)}%`,
            `${funnelData.dropoff.startToComplete.toFixed(1)}%`,
          ],
          [
            'Complete → Return Filed',
            `${funnelData.conversionRates.completeToFiled.toFixed(1)}%`,
            `${funnelData.dropoff.completeToFiled.toFixed(1)}%`,
          ],
          [
            'Overall (Click → Filed)',
            `${funnelData.conversionRates.overallConversion.toFixed(1)}%`,
            '-',
          ],
        ],
      },
    },
  ];

  // Add insights
  const insights = generateFunnelInsights(funnelData);
  if (insights) {
    sections.push({
      title: 'Insights & Recommendations',
      type: 'text',
      data: {
        text: insights,
      },
    });
  }

  const blob = await generatePDFReport({
    title: 'Conversion Funnel Report',
    sections,
    dateRange,
    generatedBy: userName,
  });

  downloadBlob(blob, `funnel-report-${new Date().toISOString().split('T')[0]}.pdf`);
}

/**
 * Generate funnel insights based on drop-off rates
 * Exported for testing (QA Gate Issue TEST-001)
 */
export function generateFunnelInsights(funnelData: FunnelData): string {
  const insights: string[] = [];

  if (funnelData.dropoff.clickToStart > 70) {
    insights.push(
      '• High drop-off between click and intake start (>70%). Consider simplifying the onboarding process or reducing friction.'
    );
  }

  if (funnelData.dropoff.startToComplete > 60) {
    insights.push(
      '• Significant drop-off during intake form completion (>60%). Form may be too long or complex. Consider breaking into smaller steps.'
    );
  }

  if (funnelData.dropoff.completeToFiled > 50) {
    insights.push(
      '• High abandonment after form completion (>50%). Follow up with users to complete their tax return filing.'
    );
  }

  if (funnelData.conversionRates.overallConversion > 15) {
    insights.push('• Excellent overall conversion rate (>15%). Current strategy is working well!');
  } else if (funnelData.conversionRates.overallConversion < 5) {
    insights.push(
      '• Low overall conversion rate (<5%). Review entire customer journey for optimization opportunities.'
    );
  }

  return insights.join('\n\n');
}

/**
 * Download blob as file
 */
function downloadBlob(blob: Blob, filename: string): void {
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  link.style.visibility = 'hidden';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);

  // Clean up
  setTimeout(() => URL.revokeObjectURL(url), 100);
}

/**
 * Format material type for display
 */
function formatType(type: string): string {
  if (!type) return 'Unknown';

  return type
    .replace(/_/g, ' ')
    .toLowerCase()
    .replace(/\b\w/g, (l) => l.toUpperCase());
}
